<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Screen Recorder + Trim + MP3 + Export</title>
  <style>
    :root { color-scheme: dark; }
    body { margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; background:#0b1020; color:#e6e9ff; }
    .wrap { max-width: 1100px; margin: 0 auto; padding: 16px; }
    h1 { font-size: 18px; margin: 0 0 10px; }
    .grid { display: grid; gap: 12px; grid-template-columns: 1fr; }
    @media (min-width: 900px) { .grid { grid-template-columns: 420px 1fr; } }
    .card { background: rgba(255,255,255,.06); border: 1px solid rgba(255,255,255,.10); border-radius: 16px; padding: 14px; box-shadow: 0 10px 30px rgba(0,0,0,.25); }
    .row { display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
    button { background:#3b82f6; color:#fff; border:0; border-radius: 12px; padding: 10px 12px; font-weight: 650; cursor:pointer; }
    button.secondary { background: rgba(255,255,255,.12); }
    button.danger { background:#ef4444; }
    button:disabled { opacity:.5; cursor:not-allowed; }
    label { font-size: 13px; opacity:.9; }
    input[type="number"], select, input[type="file"] {
      background: rgba(255,255,255,.08);
      color:#e6e9ff;
      border: 1px solid rgba(255,255,255,.12);
      border-radius: 10px;
      padding: 8px 10px;
      outline: none;
    }
    input[type="range"] { width: 100%; }
    .tiny { font-size: 12px; opacity: .8; }
    .status {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      background: rgba(0,0,0,.35);
      border: 1px solid rgba(255,255,255,.10);
      border-radius: 12px;
      padding: 10px;
      height: 190px;
      overflow: auto;
      white-space: pre-wrap;
    }
    video { width:100%; background:#000; border-radius:14px; border:1px solid rgba(255,255,255,.12); }
    .pill { display:inline-flex; align-items:center; gap:8px; padding: 6px 10px; border-radius: 999px; background: rgba(255,255,255,.08); border: 1px solid rgba(255,255,255,.10); font-size:12px; }
    a.download { display:inline-block; margin-top:10px; color:#fff; text-decoration:none; background:#22c55e; padding:10px 12px; border-radius:12px; font-weight:700; }
    hr { border:0; border-top:1px solid rgba(255,255,255,.10); margin:12px 0; }
  </style>

  <!-- ‚úÖ COI bootstrap: MUST run before ffmpeg loads -->
  <script>
    (function () {
      // GitHub Pages can't set COOP/COEP headers directly.
      // This service worker adds them so crossOriginIsolated becomes true.
      if (!window.crossOriginIsolated && "serviceWorker" in navigator) {
        navigator.serviceWorker.register("./coi-serviceworker.js", { scope: "./" })
          .then(() => navigator.serviceWorker.ready)
          .then(() => {
            // If not yet controlled, reload once to be controlled by SW.
            if (!navigator.serviceWorker.controller) location.reload();
          })
          .catch((e) => console.error("SW register failed", e));
      }
    })();
  </script>
</head>

<body>
  <div class="wrap">
    <h1>Screen Recorder ‚Üí Trim ‚Üí Add MP3 ‚Üí Export</h1>

    <div class="grid">
      <div class="card">
        <div class="row" style="justify-content: space-between;">
          <span class="pill" id="coiPill">COI: checking‚Ä¶</span>
          <span class="pill">Chrome/Edge recommended</span>
        </div>

        <hr>

        <div class="row">
          <button id="btnStart">üé¨ Start Screen Recording</button>
          <button id="btnStop" class="danger" disabled>‚èπ Stop</button>
          <button id="btnClear" class="secondary" disabled>üßπ Clear</button>
        </div>

        <div style="height:10px"></div>

        <div class="row">
          <label class="pill">
            <input type="checkbox" id="useMic" />
            Include Mic (mix with system audio)
          </label>
        </div>

        <div style="height:10px"></div>

        <div>
          <label>Music MP3 (optional)</label><br/>
          <input id="mp3File" type="file" accept="audio/mpeg,audio/mp3" />
          <div class="tiny">Use royalty-free music to avoid copyright issues.</div>
        </div>

        <div style="height:10px"></div>

        <div>
          <label>Audio mode</label><br/>
          <select id="audioMode">
            <option value="mix">Mix MP3 with recorded audio</option>
            <option value="replace">Replace recorded audio with MP3</option>
          </select>
        </div>

        <div style="height:10px"></div>

        <div>
          <label>Export format</label><br/>
          <select id="exportFormat">
            <option value="webm">WebM (recommended)</option>
            <option value="mp4">MP4 (try ‚Äî may fail)</option>
          </select>
        </div>

        <hr>

        <div class="row">
          <button id="btnLoadFfmpeg" class="secondary">‚öôÔ∏è Load Video Editor</button>
          <span class="tiny" id="ffmpegState">Editor not loaded</span>
        </div>

        <div style="height:10px"></div>

        <div>
          <label>Trim (seconds)</label>
          <div class="row" style="margin-top:6px">
            <div>
              <label class="tiny">Start</label><br/>
              <input id="trimStart" type="number" min="0" step="0.1" value="0">
            </div>
            <div>
              <label class="tiny">End</label><br/>
              <input id="trimEnd" type="number" min="0" step="0.1" value="0">
            </div>
            <div style="flex:1 1 auto">
              <label class="tiny">Quick End slider</label>
              <input id="trimSlider" type="range" min="0" max="0" step="0.1" value="0">
              <div class="tiny" id="durHint">Duration: ‚Äî</div>
            </div>
          </div>
        </div>

        <div style="height:12px"></div>

        <div class="row">
          <button id="btnExport" disabled>‚ú® Trim + Add MP3 + Export</button>
        </div>

        <a id="downloadLink" class="download" style="display:none" download>‚¨áÔ∏è Download exported video</a>
      </div>

      <div class="card">
        <label>Preview</label>
        <video id="preview" controls playsinline></video>

        <div style="height:12px"></div>
        <label>Log</label>
        <div class="status" id="log"></div>

        <div class="tiny" style="margin-top:10px">
          Export ‚Üí download ‚Üí upload to YouTube/Facebook manually.
        </div>
      </div>
    </div>
  </div>

  <script type="module">
    import { FFmpeg } from "https://unpkg.com/@ffmpeg/ffmpeg@0.12.10/dist/esm/index.js";
    import { fetchFile, toBlobURL } from "https://unpkg.com/@ffmpeg/util@0.12.1/dist/esm/index.js";

    const $ = (id) => document.getElementById(id);
    const btnStart = $("btnStart");
    const btnStop = $("btnStop");
    const btnClear = $("btnClear");
    const btnExport = $("btnExport");
    const btnLoadFfmpeg = $("btnLoadFfmpeg");

    const preview = $("preview");
    const trimStart = $("trimStart");
    const trimEnd = $("trimEnd");
    const trimSlider = $("trimSlider");
    const durHint = $("durHint");
    const downloadLink = $("downloadLink");
    const ffmpegState = $("ffmpegState");
    const coiPill = $("coiPill");

    function log(msg) {
      const el = $("log");
      el.textContent += msg + "\n";
      el.scrollTop = el.scrollHeight;
    }

    // Show COI state
    function updateCOI() {
      coiPill.textContent = "COI: " + (window.crossOriginIsolated ? "enabled ‚úÖ" : "NOT enabled ‚ùå");
      if (!window.crossOriginIsolated) {
        log("COI is not enabled yet. If you just deployed: refresh once (Ctrl+Shift+R).");
        log("If still false: ensure coi-serviceworker.js is at the same level as index.html.");
      }
    }
    updateCOI();

    // --- Recording state ---
    let recorder = null;
    let chunks = [];
    let recordedBlob = null;
    let recordedUrl = null;
    let displayStream = null;
    let micStream = null;
    let mixedStream = null;

    // --- FFmpeg state ---
    const ffmpeg = new FFmpeg();
    let ffmpegLoaded = false;

    async function loadEditor() {
      updateCOI();
      if (!window.crossOriginIsolated) {
        alert("Not crossOriginIsolated yet. Hard refresh once (Ctrl+Shift+R). If still failing, check coi-serviceworker.js path.");
        return;
      }
      if (ffmpegLoaded) return;

      try {
        btnLoadFfmpeg.disabled = true;
        ffmpegState.textContent = "Loading editor‚Ä¶";
        log("Loading ffmpeg.wasm‚Ä¶");

        ffmpeg.on("progress", ({ progress }) => {
          const pct = Math.round(progress * 100);
          ffmpegState.textContent = `Editing‚Ä¶ ${pct}%`;
        });

        const baseURL = "https://unpkg.com/@ffmpeg/core@0.12.6/dist/esm";
        const coreURL   = await toBlobURL(`${baseURL}/ffmpeg-core.js`, "text/javascript");
        const wasmURL   = await toBlobURL(`${baseURL}/ffmpeg-core.wasm`, "application/wasm");
        const workerURL = await toBlobURL(`${baseURL}/ffmpeg-core.worker.js`, "text/javascript");

        await ffmpeg.load({ coreURL, wasmURL, workerURL });
        ffmpegLoaded = true;

        ffmpegState.textContent = "Editor loaded ‚úÖ";
        log("Editor loaded ‚úÖ");

        btnExport.disabled = !recordedBlob;
      } catch (e) {
        console.error(e);
        ffmpegState.textContent = "Editor failed ‚ùå";
        log("FFMPEG LOAD ERROR: " + (e?.message || e));
        alert("Video Editor failed to load. Check Log.");
      } finally {
        btnLoadFfmpeg.disabled = false;
      }
    }

    async function getMixedStreamWithOptionalMic(screenStream, includeMic) {
      const videoTracks = screenStream.getVideoTracks();
      const hasScreenAudio = screenStream.getAudioTracks().length > 0;

      if (!includeMic && hasScreenAudio) return screenStream;
      if (!includeMic && !hasScreenAudio) return new MediaStream([...videoTracks]);

      const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      const destination = audioCtx.createMediaStreamDestination();

      if (hasScreenAudio) {
        const src = audioCtx.createMediaStreamSource(new MediaStream(screenStream.getAudioTracks()));
        src.connect(destination);
      }

      if (includeMic) {
        micStream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
        const micSrc = audioCtx.createMediaStreamSource(micStream);
        micSrc.connect(destination);
      }

      return new MediaStream([...videoTracks, ...destination.stream.getAudioTracks()]);
    }

    function stopAllTracks(stream) {
      if (!stream) return;
      stream.getTracks().forEach(t => t.stop());
    }

    async function startRecording() {
      downloadLink.style.display = "none";
      downloadLink.removeAttribute("href");
      chunks = [];
      recordedBlob = null;

      try {
        displayStream = await navigator.mediaDevices.getDisplayMedia({
          video: { frameRate: 30 },
          audio: true
        });

        mixedStream = await getMixedStreamWithOptionalMic(displayStream, $("useMic").checked);

        const candidates = [
          "video/webm;codecs=vp9,opus",
          "video/webm;codecs=vp8,opus",
          "video/webm"
        ];
        const mimeType = candidates.find(t => MediaRecorder.isTypeSupported(t)) || "";

        recorder = new MediaRecorder(mixedStream, mimeType ? { mimeType } : undefined);

        recorder.ondataavailable = (e) => {
          if (e.data && e.data.size > 0) chunks.push(e.data);
        };

        recorder.onstop = () => {
          recordedBlob = new Blob(chunks, { type: recorder.mimeType || "video/webm" });
          log(`Recorded: ${(recordedBlob.size/(1024*1024)).toFixed(2)} MB`);

          if (recordedUrl) URL.revokeObjectURL(recordedUrl);
          recordedUrl = URL.createObjectURL(recordedBlob);
          preview.src = recordedUrl;

          preview.onloadedmetadata = () => {
            const dur = preview.duration || 0;
            durHint.textContent = `Duration: ${dur.toFixed(2)}s`;
            trimStart.value = "0";
            trimEnd.value = dur.toFixed(2);
            trimSlider.max = dur.toFixed(2);
            trimSlider.value = dur.toFixed(2);

            btnClear.disabled = false;
            btnExport.disabled = !ffmpegLoaded;
          };

          stopAllTracks(displayStream);
          stopAllTracks(micStream);
          displayStream = null;
          micStream = null;
          mixedStream = null;
        };

        recorder.start(250);
        log("Recording started‚Ä¶");
        btnStart.disabled = true;
        btnStop.disabled = false;
        btnClear.disabled = true;
        btnExport.disabled = true;

      } catch (e) {
        console.error(e);
        log("RECORD ERROR: " + (e?.message || e));
        stopAllTracks(displayStream);
        stopAllTracks(micStream);
        displayStream = null; micStream = null; mixedStream = null;
      }
    }

    function stopRecording() {
      if (recorder && recorder.state !== "inactive") recorder.stop();
      log("Recording stopped.");
      btnStop.disabled = true;
      btnStart.disabled = false;
    }

    function clearAll() {
      if (recordedUrl) URL.revokeObjectURL(recordedUrl);
      recordedUrl = null;
      recordedBlob = null;
      preview.removeAttribute("src");
      preview.load();
      durHint.textContent = "Duration: ‚Äî";
      trimStart.value = "0";
      trimEnd.value = "0";
      trimSlider.max = "0";
      trimSlider.value = "0";
      downloadLink.style.display = "none";
      btnClear.disabled = true;
      btnExport.disabled = true;
      log("Cleared.");
    }

    function clamp(n, min, max) { return Math.max(min, Math.min(max, n)); }

    async function exportEdited() {
      if (!ffmpegLoaded) { alert("Click 'Load Video Editor' first."); return; }
      if (!recordedBlob) { alert("Record something first."); return; }

      const duration = preview.duration || 0;
      const start = clamp(Number(trimStart.value || 0), 0, duration);
      const end   = clamp(Number(trimEnd.value   || 0), 0, duration);
      if (end <= start + 0.01) { alert("Trim end must be greater than trim start."); return; }

      const mp3 = $("mp3File").files?.[0] || null;
      const audioMode = $("audioMode").value;
      const exportFormat = $("exportFormat").value;
      const trimLen = end - start;

      btnExport.disabled = true;
      btnStart.disabled = true;
      btnStop.disabled = true;
      btnClear.disabled = true;
      downloadLink.style.display = "none";

      try {
        log("Preparing ffmpeg‚Ä¶");

        for (const f of ["input.webm","trimmed.webm","music.mp3","out.webm","out.mp4"]) {
          try { await ffmpeg.deleteFile(f); } catch {}
        }

        await ffmpeg.writeFile("input.webm", await fetchFile(recordedBlob));

        log(`Trimming: ${start.toFixed(2)}s ‚Üí ${end.toFixed(2)}s`);
        await ffmpeg.exec([
          "-ss", String(start),
          "-to", String(end),
          "-i", "input.webm",
          "-c:v", "libvpx",
          "-crf", "30",
          "-b:v", "0",
          "-c:a", "libopus",
          "-b:a", "128k",
          "trimmed.webm"
        ]);

        if (mp3) {
          log(`Adding MP3 (${audioMode})‚Ä¶`);
          await ffmpeg.writeFile("music.mp3", await fetchFile(mp3));

          if (audioMode === "replace") {
            await ffmpeg.exec([
              "-i", "trimmed.webm",
              "-stream_loop", "-1",
              "-i", "music.mp3",
              "-t", String(trimLen),
              "-map", "0:v:0",
              "-map", "1:a:0",
              "-c:v", "copy",
              "-c:a", "libopus",
              "-shortest",
              "out.webm"
            ]);
          } else {
            await ffmpeg.exec([
              "-i", "trimmed.webm",
              "-stream_loop", "-1",
              "-i", "music.mp3",
              "-t", String(trimLen),
              "-filter_complex", "[0:a][1:a]amix=inputs=2:duration=first:dropout_transition=2[a]",
              "-map", "0:v:0",
              "-map", "[a]",
              "-c:v", "copy",
              "-c:a", "libopus",
              "-shortest",
              "out.webm"
            ]);
          }
        } else {
          log("No MP3 selected ‚Üí exporting trimmed only‚Ä¶");
          await ffmpeg.exec(["-i", "trimmed.webm", "-c:v", "copy", "-c:a", "copy", "out.webm"]);
        }

        let outName = "out.webm";
        if (exportFormat === "mp4") {
          log("Trying MP4 export‚Ä¶");
          try {
            await ffmpeg.exec([
              "-i", "out.webm",
              "-c:v", "libx264",
              "-preset", "veryfast",
              "-crf", "23",
              "-c:a", "aac",
              "-b:a", "160k",
              "out.mp4"
            ]);
            outName = "out.mp4";
            log("MP4 export success ‚úÖ");
          } catch {
            log("MP4 export failed ‚Üí keeping WebM.");
            outName = "out.webm";
          }
        }

        const data = await ffmpeg.readFile(outName);
        const outBlob = new Blob([data.buffer], { type: outName.endsWith(".mp4") ? "video/mp4" : "video/webm" });
        const outUrl = URL.createObjectURL(outBlob);

        preview.src = outUrl;
        downloadLink.href = outUrl;
        downloadLink.download = outName.endsWith(".mp4") ? "exported.mp4" : "exported.webm";
        downloadLink.style.display = "inline-block";

        log(`Done ‚úÖ Exported ${(outBlob.size/(1024*1024)).toFixed(2)} MB`);
      } catch (e) {
        console.error(e);
        log("EXPORT ERROR: " + (e?.message || e));
        alert("Export failed. Check Log. Tip: try WebM + shorter clip.");
      } finally {
        btnExport.disabled = false;
        btnStart.disabled = false;
        btnStop.disabled = true;
        btnClear.disabled = false;
      }
    }

    btnStart.addEventListener("click", startRecording);
    btnStop.addEventListener("click", stopRecording);
    btnClear.addEventListener("click", clearAll);
    btnLoadFfmpeg.addEventListener("click", loadEditor);
    btnExport.addEventListener("click", exportEdited);

    trimSlider.addEventListener("input", () => trimEnd.value = Number(trimSlider.value).toFixed(2));
    trimEnd.addEventListener("input", () => trimSlider.value = trimEnd.value || "0");

    log("If deployed on GitHub Pages: open once ‚Üí refresh once ‚Üí then COI becomes enabled ‚úÖ.");
  </script>
</body>
</html>
